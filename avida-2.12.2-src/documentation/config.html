<html>
<head>
  <title>Avida : The Avida Configuration File</title>
	<link rel="stylesheet" type="text/css" href="main.css" />
</head>
<body>

<div class="revision">
Revised 2010-11-16 DMB
</div>

<p><a href="index.html">Return to the Index</a></p>
<hr />

<div align="center">
<h1>The Avida Configuration File</h2>
</div>

<p>
The Avida configuration file (<kbd>avida.cfg</kbd>)
is the main configuration file for Avida.  With this file, the user can
setup all of the basic conditions for a run.  Below are detailed descriptions
for some of the settings in the configuration file, with particularly important
settings highlighted in green.  The non-colored entries will probably never
need to change unless you are performing a very specialized experiment.
</p>

<p>&nbsp;</p>
<h2>General Variables</h2>

<p>
This section covers all of the basic variables that describe the Avida run.

</p>
<table border="1">
<tr class="important">
  <td valign="top"><strong><code>
    RANDOM_SEED
  </code></strong></td>
  <td>
    The random number seed initializes the random number generator.  You
    should alter only this seed if you want to perform a collection of
    replicate runs.  Setting the random number seed to zero (or a negative
    number) will base the seed on the starting time of the run
    -- effectively a random random number seed.  In practice, you want
    to always be able to re-do an exact run in case you want to get
    more information about what happened.
  </td>
</tr>
<tr>
  <td valign="top"><strong><code>
    POPULATION_CAP
  </code></strong></td>
  <td>
    The carrying capacity of the population (in number of organisms).  Use 0 for no cap.
  </td>
</tr>
</table>



<p>&nbsp;</p>
<h2>Topology Variables</h2>

<p>
This section covers all of the basic topoloyg variables that describe the structure of the world.
</p>
<table border="1">
<tr class="important">
  <td valign="top"><strong><code>
    WORLD_X
    <br />WORLD_Y
  </code></strong></td>
  <td>
    The settings determine the size of the Avida grid that the organisms populate.
    In mass action mode the shape of the grid is not relevant, only the number of
    organisms that are in it.
  </td>
</tr>
</table>


<p>&nbsp;</p>
<h2>Configuration Files</h2>

<p>
This section relates Avida to other files that it requires.
</p>
<table border="1">
<tr class="important">
  <td valign="top"><strong><code>DATA_DIR</code></strong></td>
  <td>
    The name (or path) of the directory where output files generated by Avida should be placed.
  </td>
</tr>
<tr class="important">
  <td valign="top"><strong><code>
    EVENT_FILE
    <br />ANALYZE_FILE
    <br />ENVIRONMENT_FILE
  </code></strong></td>
  <td>
    These settings indicate the names of all of the other configuration files
    used in an Avida run.  See the individual documents for more information
    about how to use these files.
  </td>
</tr>
</table>


<p>&nbsp;</p>
<h2>Instruction Set</h2>

<p>
See <a href="inst_set.html">The Instruction Set</a> for details.
</p>


<p>&nbsp;</p>
<h2>Reproduction</h2>

<p>
These settings control how creatures are born and die in Avida.
</p>
<table border="1">
<tr class="important">
  <td valign="top"><strong><code>BIRTH_METHOD</code></strong></td>
  <td>
    The birth method sets how the placement of a child organism is
    determined.  Currently, there are six ways of doing this -- the
    first four (0-3) are all grid-based (offspring are only placed
    in the immediate neighborhood), and the last two (4-5) assume
    a well-stirred population.  In all non-random methods, empty
    sites are preferred over replacing a living organism.
  </td>
</tr>
<tr>
  <td valign="top"><strong><code>
    DEATH_METHOD
    <br />AGE_LIMIT
  </code></strong></td>
  <td>
    By default, replacement is the only way for an organism to die in
    Avida.  However, if a death method is set, organisms will die of
    old age.  In method one, organisms will die when they reach the
    user-specified age limit.  In method 2, the age limit is a multiple
    of their length, so larger organisms can live longer.
  </td>
</tr>
<tr>
  <td valign="top"><strong><code>ALLOC_METHOD</code></strong></td>
  <td>
    During the replication process in the default virtual CPU, parent
    organisms must allocate memory space for their child-to-be.  Before
    the child is copied into this new memory, it must have an initial
    value.  Setting the alloc method to zero sets this memory to a default
    instruction (typical nop-A).  Mode 1 leaves it uninitialized (and hence
    keeps the contents of the last organism that inhabited that space; if
    only a partial copy occurs, the child is a hybrid if the parent and the
    dead organism, hence the name necrophilia).  Mode 2 just randomizes each
    instruction.  This means that the organism will behave unpredictably if
    the uninitialized code is executed.
  </td>
</tr>
<tr>
  <td valign="top"><strong><code>DIVIDE_METHOD</tt></b>
  <td>
    When a divide occurs, does the parent divide into two children, or else
    do we have a distinct parent and child?  The latter method will allow more
    age structure in a population where an organism may behave differently
    when it produces its second or later offspring.
  </td>
</tr>
<tr>
  <td valign="top"><strong><code>GENERATION_INC_METHOD</code></strong></td>
  <td>
    The generation of an organism is the number of organisms in the chain
    between it and the original ancestor.  Thus, the generation of a population
    can be calculated as the average generation of the individual organisms.
    When a divide occurs, the child always receives a generation one higher
    than the parent, but what should happen to the generation of the parent
    itself?  In general, this should be set the same as divide method.
  </td>
</tr>
</table>


<p>&nbsp;</p>
<h2>Mutations</h2>

<p>
These settings control how and when mutations occur in organisms.  Ideally,
there will be more options here in the future.
</p>
<table border="1">
<tr>
  <td valign="top"><strong><code>POINT_MUT_PROB</code></strong></td>
  <td>
    Point mutations (sometimes referred to as "cosmic ray" mutations)
    occur every update; the rate set here is a probability for each site
    that it will be mutated each update.  In other words, this should
    be a very low value if it is turned on at all.  If a mutation occurs,
    that site is replaced with a random instruction.  In practice this
    also slows Avida down if it is non-zero because it requires so many
    random numbers to be tested every update.
  </td>
</tr>
<tr class="important">
  <td valign="top"><strong><code>COPY_MUT_PROB</code></strong></td>
  <td>
    The copy mutation probability is tested each time an organism copies 
    a single instruction.  If a mutation occurs, a random instruction is
    copied to the destination.  In practice this is the most common type
    of mutations that we use in most of our experiments.
  </td>
</tr>
<tr class="important">
  <td valign="top"><strong><code>
    DIV_INS_PROB
    <br />DIV_DEL_PROB
  </code></strong></td>
  <td>
    These probabilities are tested once per gestation cycle (when an
    organism is first born) at each position where an instruction could
    be inserted or deleted, respectively.  Each of these mutations change
    the genome length.  Deletions just remove an instruction while
    insertions add a new, random instruction at the position tested.
    Multiple insertions and deletions are possible each generation.
  </td>
</tr>
<tr class="important">
  <td valign="top"><strong><code>
    DIVIDE_MUT_PROB
    <br />DIVIDE_INS_PROB
    <br />DIVIDE_DEL_PROB
  </code></strong></td>
  <td>
    Divide mutation probabilities are tested when an organism is
    being divided off from its parent.  If one of these mutations
    occurs, a random site is picked for it within the genome.  At most
    one divide mutation of each type is possible during a single
    divide.
  </td>
</tr>
</table>




<p>&nbsp;</p>
<h2>Divide Restrictions</h2>

<p>
These place limits on when an organism can successfully issue a divide
command to produce an offspring.
</p>
<table border="1">
<tr class="important">
  <td valign="top"><strong><code>OFFSPRING_SIZE_RANGE</code></strong></td>
  <td>
    This is the maximal difference in genome size between a parent and
    offspring.  The default of 2.0 means that the genome of the child
    must be between one-half and twice the length of the parent.  This
    it to prevent out-of-control size changes.  Setting this to 1.0 will
    ensure fixed length organisms (but make sure to also turn off
    insertion and deletion mutations).
  </td>
</tr>
<tr>
  <td valign="top"><strong><code>
    MIN_COPIED_LINES
    <br />MIN_EXE_LINES
  </code></strong></td>
  <td>
    These settings place limits on what the parent must have done before
    the offspring can be born; they set the minimum fraction of instructions
    that must have been copied into the offspring (vs. left as default) and
    the minimum fraction of instructions in the parent that must have
    been executed.  If either of these are not met, the divide will fail.
    These settings prevent organisms from producing pathological offspring.
    In practice, either of them can be set to 0.0 to turn them off.
  </td>
</tr>
<tr>
  <td valign="top"><strong><code>REQUIRE_ALLOCATE</code></strong></td>
  <td>
    Is an allocate required between each successful divide (in virtual
    hardware types where allocate is meaningful)?  If so,
    this will limit the flexibility of how organisms produce children
    (they can't make multiple copies and divide them off all at once,
    for example).  But if we don't require allocates, the resulting
    organisms can be a lot more difficult to understand.
  </td>
</tr>
<tr>
  <td valign="top"><strong><code>REQUIRED_TASK</code></strong></td>
  <td>
    This was originally a hack.  It allows the user to set the ID number
    for a task that <i>must</i> occur for a divide to be successful.
    At -1, no tasks are required.  Ideally, this should be incorporated
    into the environment configuration file.  NOTE: A task can fire without
    triggering a reaction. To add a required reaction see below.
  </td>
</tr>
<tr>
  <td valign="top"><strong><code>IMMUNITY_TASK</code></strong></td>
  <td>
    Allows user to set the ID number for a task which, if it occures, 
    provides immunity from the required task (above) -- divide will 
    proceede even if the required task is not done if immunity task is done. 
    Defaults to -1, no immunity task present.
  </td>
</tr>
<tr>
  <td valign="top"><strong><code>REQUIRED_REACTION</code></strong></td>
  <td>
    Allows the user to set the ID number for a reaction that <em>must</em> 
    occur for a divide to be successful.  At -1, no reactions are required.
  </td>
</tr>
</table>



<p>&nbsp;</p>
<h2>Mutation Reversions</h2>

<p>
This section covers tests that are very CPU intensive, but allow for
Avida experiments that would not be possible in any other system. Basically,
each time a mutation occurs, we can run the resulting organism in a
test CPU, and determine if that effect of the mutation was lethal, detrimental,
neutral, or beneficial.  This section allows us to act on this.  (Note that as
soon as anything here is turned on, the mutations need to be tested.  Turning
multiple settings on will not cause additional speed decrease)
</p>
<table border="1">
<tr>
  <td valign="top"><strong><code>
    REVERT_FATAL
    <br />REVERT_DETRIMENTAL
    <br />REVERT_NEUTRAL
    <br />REVERT_BENEFICIAL
  </code></strong></td>
  <td>
    When a mutation occurs of the specified type, the number
    listed next to that entry is the probability that the mutation will
    be reverted.  That is, the child organism's genome will be restored
    as if the mutation had never occurred.  This allows us both to 
    manually manipulate the abundance of certain mutation types, or
    to entirely eliminate them.
  </td>
</tr>
<tr>
  <td valign="top"><strong><code>
    STERILIZE_FATAL
    <br />STERILIZE_DETRIMENTAL
    <br />STERILIZE_NEUTRAL
    <br />STERILIZE_BENEFICIAL
  </code></strong></td>
  <td>
    The sterilize options work similarly to revert; the
    difference being that an organism never has its genome restored.
    Instead, if the selected mutation category occurs, the child is
    sterilized so that it still takes up space, but can never produce an
    offspring of its own.
  </td>
</tr>
<tr>
  <td valign="top"><strong><code>STERILIZE_UNSTABLE</code></strong></td>
  <td>
    If this toggle is set, organisms <em>must</em> be able to produce
    exact copies of themselves or else they are sterilized and cannot
    produce any offspring.  An organism that naturally (without any
    external effects) produces an inexact copy of itself is said to
    have implicit mutations.  If this flag is set, explicit mutations
    (as described in the mutations section above) can still occur.
</table>


<p>&nbsp;</p>
<h2>Time Slicing</h2>

<p>
These settings describe exactly what an update is, and how CPU time is
allocated to organisms during that update.
</p>
<table border="1">
<tr>
  <td valign="top"><strong><code>AVE_TIME_SLICE</code></strong></td>
  <td>
    This sets the average number of instructions an organism should
    execute each update.  Organisms with a low merit will consistently
    obtain fewer, while organisms of a higher merit will receive more.
  </td>
</tr>
<tr>
  <td valign="top"><strong><code>SLICING_METHOD</code></strong></td>
  <td>
    This setting determines the method by which CPU time is handed out
    to the organisms.  Method 0 ignores merit, and hands out time on the
    CPU evenly; each organism executes one instruction for the whole
    population before moving onto the second.  Method 1 is
    probabilistic; each organism has a chance of executing the
    next instruction proportional to it merit.  This method is slow
    due to the large number of random values that need to be obtained
    and evaluated (and it only gets slower as merits get higher).
    Method 2 is fully integrated; the organisms get CPU time proportional
    to their merit, but in a fixed, deterministic order.
  </td>
</tr>
<tr>
  <td valign="top"><strong><code>BASE_MERIT_METHOD</code></strong></td>
  <td>
    This setting determines the base value of an organism's merit.
    Merit is typically proportional to genome length otherwise there
    is a strong selective pressure for shorter genomes (shorter genome
    => less to copy => reduced copying time => replicative advantage).
    Unfortunately, organisms will cheat if merit is proportional to 
    the full genome length -- they will add on unexecuted and uncopied
    code to their genomes creating a code bloat.  This isn't the most
    elegant fix, but it works.
  </td>
</tr>
<tr>
  <td valign="top"><strong><code>MAX_LABEL_EXE_SIZE</code></strong></td>
  <td>
    Labels are sequences of nop (no-operation) instructions used only
    to modify the behavior of other instructions.  Quite often, an
    organism will have these labels in their genomes where the nops are
    used by another instruction, but never executed directly.  To
    represent the executed length of an organism correctly, we need to
    somehow count these labels.  Unfortunately, if we count the entire
    label, the organisms will again "cheat" artificially increasing
    their length by growing huge labels.  This setting limits the 
    number of nops that are counted as executed when a label is used.
  </td>
</tr>
<tr>
  <td valign="top"><strong><code>MAX_CPU_THREADS</code></strong></td>
  <td>
    Determines the number of simultaneous processes that an organism
    can run.  That is, basically, the number of things it can do at once. 
    This setting is meaningless unless threads are supported in the virtual
    hardware and the instructions are available within the instruction set.
  </td>
</tr>
</table>


<p>&nbsp;</p>
<h2>Geneology Info</h2>

<p>
These settings control how Avida monitors and deals with genotypes,
species, and lineages.
</p>
<table border="1">
<tr>
  <td valign="top"><strong><code>THRESHOLD</code></strong></td>
  <td>
    For some statistics, we only want to measure organisms that we are
    sure are alive, but its not worth taking the time to run them all
    in isolation, without outside effect (and in some eco-system situations
    that isn't even possible!).  For these purposes, we call a genotype
    "threshold" if there have ever been more than a certain number of
    organisms of that genotype.  A higher number here ensures a greater
    probability that the organisms are indeed "alive".  Recently, we've
    been shifting away from using threshold genotypes and instead finding
    other, more accurate testing methods.
  </td>
</tr>
<tr>
  <td valign="top"><strong><code>TEST_CPU_TIME_MOD</code></strong></td>
  <td>
    Many of our analysis methods (such as species testing) require that
    we be able to run organisms in isolation.  Unfortunately, some of
    these organisms we test might be non-viable.  At some point, we have
    to give up the test and label it as non-viable, but we can't give up
    too soon or else we might miss a viable, though slow replicator.
    This setting is multiplied by the length of the organism's genome in
    order to determine how many CPU-cycles to run the organism for.  A
    setting of 20 effectively means that the average instruction must
    be executed twenty times before we give up.  In practice, most
    organisms have an efficiency here of about 5, so 20 works well, but
    for accurate tests on some pathological organisms, we will be
    required to raise this number.
  </td>
</tr>
</table>


<p>&nbsp;</p>
<h2>Log Files</h2>

<p>
Log files are printed every time a specified event occurs.  By default,
all logs settings are 0 (i.e. the logs are turned off).  Each time a logged
event is printed, the update and identifying information on the individual
that triggered it is always included.
</p>
<table border="1">
<tr>
  <td valign="top"><strong><code>LOG_GENOTYPES</code></strong></td>
  <td>
    If toggle is set, print an entry to <kbd>genotype.log</kbd>
    whenever a new genotype is created. Includes information on its parent
    genotype.
  </td>
</tr>
<tr>
  <td valign="top"><strong><code>LOG_THRESHOLD</code></strong></td>
  <td>
    If toggle is set, print an entry to <kbd>threshold.log</kbd>
    whenever a genotype reaches threshold.  Includes information on what
    species it is.
  </td>
</tr>
<tr>
  <td valign="top"><strong><code>LOG_LINEAGES</code></strong></td>
  <td>
    Lineages can be given unique identifies and printed (into the file
    <kbd>lineage.log</kbd>) whenever they are created.
    Includes details about the event that created the lineage.
  </td>
</tr>
<tr>
  <td valign="top"><strong><code>LINEAGE_CREATION_METHOD</code></strong></td>
  <td>
    Details when lineages are created.  See config file comments for
    more detailed information.
  </td>
</tr>
</table>

<hr />
<p><a href="index.html">Return to the Index</a></p>

</body>
</html>
