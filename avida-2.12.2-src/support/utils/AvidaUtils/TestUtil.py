import os
import os.path
import shutil
import sys
import tempfile

def PhonyTarget(alias, action, depends = None):
  """Returns an alias to a command that performs the action.
  Implementated by a Command with a nonexistant file target.  This command will
  run on every build, and will never be considered 'up to date'. Acts like a
  'phony' target in make.
  """
  phony_file = os.path.normpath(tempfile.mktemp(prefix="phony_%s_" % alias, dir="."))
  Depends(phony_file, depends)
  return Alias(alias, Command(target=phony_file, source=None, action=action))

def Test(env, prg):
  """Creates unit test from given program.
  When unit test passes, a file stamp is made. If it ran successfully and there
  is nothing changed, the unit test can be skipped next time.

  Makes three alii: the name of program, force-test, and test-changed:
  - First can be used to run individual unit test.
  - Second is used to run changed unit tests.
  - Third forces all unit tests to run.
  """
  name = str(prg[0])
  stamp = name + '.passed'
  env.UnitTest(stamp, prg)
  alias = PhonyTarget(name, [prg], stamp)
  env.Alias('force-test', name)
  env.Alias('test-changed', stamp)
    
def TestList(env, name, list, *args, **kw):
  """Creates a set of unit tests from given list of filename bases.
    
  For each filename base 'blah', tries to make unit test using filename
  'blah.cc'.  Creates alias, of given name, to all tests in this set.
  """
  for i in list:
    Test(e, e.Program(i, i + '.cc', *args, **kw))
  Alias(name, list)



class TailChecker:
  """
  Class that uses Avida and an Avida configuration to produce a set of
  last lines of Avida output files, and then compares them to a set of
  corresponding expected last lines that were generated by the companion
  class TailGenerator.
  """
  def __init__(self,
    seed_set,
    run_subdir_path_base,
    output_file_name,
    expectation_file_path_base,
    expectation_file_name,
    avida_exe_path,
    avida_args
  ):
    self.seed_set = seed_set
    self.run_subdir_path_base = run_subdir_path_base
    self.output_file_name = output_file_name
    self.expectation_file_path_base = expectation_file_path_base
    self.expectation_file_name = expectation_file_name
    self.avida_exe_path = avida_exe_path
    self.avida_args = avida_args

    self.failures_dict = {}

  def _check_tail(self, seed):
    run_subdir = self.run_subdir_path_base + str(seed)
    expectation_file_dir = self.expectation_file_path_base + str(seed)
    expectation_file_path = expectation_file_dir + '/' + self.expectation_file_name
    avida_command = self.avida_exe_path + ' ' + self.avida_args % {'Seed': str(seed), 'DataDir': run_subdir}

    try:
      os.makedirs(run_subdir)
    except OSError:
      pass

    expected_last_line_fd = file(expectation_file_path, "rU")

    avida_output_fd = os.popen(avida_command, 'r', -1)
    line = avida_output_fd.readline()
    while line != "":
      print line,
      line = avida_output_fd.readline()
    avida_output_fd.close()

    detail_fd = file(os.path.join(run_subdir, self.output_file_name),"rU") 
    next_detail_line = detail_fd.readline()
    while next_detail_line != "":
      last_detail_line = next_detail_line
      next_detail_line = detail_fd.readline()
    detail_fd.close()

    print "last line of output file \"" + self.output_file_name + "\" : "
    print last_detail_line
    
    expected_last_detail_line = expected_last_line_fd.readline()
    expected_last_line_fd.close()

    if last_detail_line != expected_last_detail_line:
      print "last line of output file doesn't match expected last line."
      self.failures_dict[seed] = (last_detail_line, expected_last_detail_line)
    else:
      print "last line of output file matches expected last line."

  def check_tails(self):
    for seed in self.seed_set:
      print 'trying seed', seed, 'of seed_set', self.seed_set
      self._check_tail(seed)


def tail_checker_action(target, source, env):
  """
  An SCons Action used by ConsistencyCheck() to consistency-check Avida
  using a TailChecker instance.
  """
  events_file = tempfile.mkstemp('.cfg', 'events.')
  os.write(events_file[0],
'''
u %(run_length)s:%(run_length)s detail_pop %(output_file_name)s   # Save current state of population.
u %(run_length)s exit   # exit.
''' % {'run_length': env['run_length'], 'output_file_name': env['output_file_name']}
  )
  os.close(events_file[0])

  tail_checker = TailChecker(
    seed_set = env['seed_set'],
    run_subdir_path_base = env['run_subdir_path_base'],
    output_file_name = env['output_file_name'],
    expectation_file_path_base = env['expectation_file_path_base'],
    expectation_file_name = env['expectation_file_name'],
    avida_exe_path = env['avida_exe_path'],
    avida_args = env['avida_args'] % {'Seed':'%(Seed)s', 'DataDir':'%(DataDir)s', 'EventsFile':events_file[1]}
  )
  tail_checker.check_tails()

  os.remove(events_file[1])

  for seed, lines in tail_checker.failures_dict.iteritems():
    print 'Seed', seed, 'produced unexpected last line in file', env['output_file_name'], ':'
    print lines[0], 'Expected last line in file', env['expectation_file_name'], ':'
    print lines[1]
  if 0 is not len(tail_checker.failures_dict):
    return 1


class TailGenerator:
  """
  Class that uses Avida to generate a set of expected last lines of output
  files for a particular Avida configuration.
  
  The companion class TailChecker can subsequently use Avida with the same
  configuration to generate a set of actual last lines of corresponding
  output files, compare them to the expected last lines, and report the
  result.
  """
  def __init__(self,
    seed_set,
    run_subdir_path_base,
    output_file_name,
    expectation_file_path_base,
    expectation_file_name,
    avida_exe_path,
    avida_args
  ):
    self.seed_set = seed_set
    self.run_subdir_path_base = run_subdir_path_base
    self.output_file_name = output_file_name
    self.expectation_file_path_base = expectation_file_path_base
    self.expectation_file_name = expectation_file_name
    self.avida_exe_path = avida_exe_path
    self.avida_args = avida_args

  def _generate_tail(self, seed):
    run_subdir = self.run_subdir_path_base + str(seed)
    expectation_file_dir = self.expectation_file_path_base + str(seed)
    expectation_file_path = expectation_file_dir + '/' + self.expectation_file_name
    avida_command = self.avida_exe_path + ' ' + self.avida_args % {'Seed': str(seed), 'DataDir': run_subdir}

    try:
      os.makedirs(run_subdir)
    except OSError:
      pass
    try:
      os.makedirs(expectation_file_dir)
    except OSError:
      pass

    expected_last_line_fd = file(expectation_file_path, "wU")

    avida_output_fd = os.popen(avida_command, 'r', -1)
    line = avida_output_fd.readline()
    while line != "":
      print line,
      line = avida_output_fd.readline()
    avida_output_fd.close()

    detail_fd = file(os.path.join(run_subdir, self.output_file_name),"rU")
    next_detail_line = detail_fd.readline()
    while next_detail_line != "":
      last_detail_line = next_detail_line
      next_detail_line = detail_fd.readline()
    detail_fd.close()

    print "last line of output file \"" + self.output_file_name + "\" : "
    print last_detail_line
    
    expected_last_line_fd.write(last_detail_line)
    expected_last_line_fd.close()

  def generate_tails(self):
    for seed in self.seed_set:
      self._generate_tail(seed)


def tail_generator_action(target, source, env):
  """
  An SCons Action used by ConsistencyCheck() to generate Avida
  consistency-check expectation files, using a TailGenerator instance.
  """
  events_file = tempfile.mkstemp('.cfg', 'events.')
  os.write(events_file[0],
'''
u %(run_length)s:%(run_length)s detail_pop %(output_file_name)s   # Save current state of population.
u %(run_length)s exit   # exit.
''' % {'run_length': env['run_length'], 'output_file_name': env['output_file_name']}
  )
  os.close(events_file[0])

  tail_generator = TailGenerator(
    seed_set = env['seed_set'],
    run_subdir_path_base = env['run_subdir_path_base'],
    output_file_name = env['output_file_name'],
    expectation_file_path_base = env['expectation_file_path_base'],
    expectation_file_name = env['expectation_file_name'],
    avida_exe_path = env['avida_exe_path'],
    avida_args = env['avida_args'] % {'Seed':'%(Seed)s', 'DataDir':'%(DataDir)s', 'EventsFile':events_file[1]}
  )
  tail_generator.generate_tails()

  os.remove(events_file[1])


def ConsistencyCheck(env, name, *args, **kw):
  """
  Creates SCons targets to run Avida consistency checks, or generate
  consistency-check expectation files.
  """
  env.AlwaysBuild(env.Alias('Consistency-Check--' + name, [], tail_checker_action, *args, **kw))
  env.AlwaysBuild(env.Alias('Consistency-Check', [], tail_checker_action, *args, **kw))

  env.AlwaysBuild(env.Alias('Generate-Consistency-Check--' + name, [], tail_generator_action, *args, **kw))


